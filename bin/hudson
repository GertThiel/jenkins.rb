#!/usr/bin/env ruby
require 'rubygems'
require 'un'
require 'optparse'
require 'term/ansicolor' # gem: term-ansicolor
$:.unshift(File.expand_path(File.dirname(File.dirname(__FILE__) + "/../lib/hudson.rb")))
require File.dirname(__FILE__) + '/../lib/hudson'

def display(text)
  puts text
  exit
end

def error(text)
  $stderr.puts "ERROR: #{text}"
  exit
end

options = {
  :port => ENV['HUDSON_PORT'] || '3001',
  :control => ENV['HUDSON_CONTROL'] || '3002',
  :host => ENV['HUDSON_HOST'] || 'localhost',
  :home => File.join(ENV['HOME'], '.hudson')
}
args = ARGV.dup

c = Term::ANSIColor

def common_hudson_options(opts, options)
  opts.on("-p", "--port [3001]", "find hudson on specified port") do |port|
    options[:port] = port
  end
  opts.on("--host [localhost]", "find hudson on specified host") do |host|
    options[:host] = host
  end
  opts.on_tail("-h", "--help") { display opts }
end

def help(opts)
  puts "Hudson.rb is a smart set of utilities for making\ncontinuous integration as simple as possible\n\n"
  puts <<-USAGE
  Usage:
    hudson -h/--help
    hudson -v/--version
    hudson (server|create|list|help) [arguments...] [options...]

  Examples:
    hudson server --port 8080
    hudson remote list
    hudson help server
USAGE
end

opts = OptionParser.new do |opts|
  opts.banner = "Usage: hudson [command] [options] [HUDSON_HOME]"

  opts.on_tail("-v", "--version", "show version information") do
    display "#{Hudson::VERSION} (Hudson Server #{Hudson::HUDSON_VERSION})"
  end
  opts.on_tail("-h", "--help") { display opts }
end

if command = args.shift
  case command.to_sym
  when :help
    help(opts)
  when :server
    opts = OptionParser.new do |opts|
      opts.banner = "Usage: hudson server [options] [HUDSON_HOME]"

      opts.on("-d", "--daemon", "fork into background and run as daemon") do
        options[:daemon] = true
      end

      opts.on("-p", "--port [3001]", "run hudson on specified port ") do |port|
        options[:port] = port
      end

      opts.on("-c", "--control-port [3002]", Integer, "set the shutdown/control port") do |port|
        options[:control] = port
      end

      opts.on("-l", "--logfile PATH", String, "redirect log messages to this file") do |path|
        options[:logfile] = path
      end

      opts.on_tail("-k", "--kill", "send shutdown signal to control port") do
        options[:kill] = true
      end

      opts.on_tail("-h", "--help") { display opts }
    end

    opts.parse!(args)
    if options[:kill]
      require 'socket'
      TCPSocket.open("localhost", options[:control]) do |sock|
        sock.write("0")
      end
      exit
    end

    dir = args.shift || options[:home]
    serverhome = File.join(dir, "server")
    javatmp = File.join(serverhome, "javatmp")
    FileUtils.mkdir_p dir
    FileUtils.mkdir_p javatmp
    FileUtils.cp_r Hudson::PLUGINS, serverhome
    ENV['HUDSON_HOME'] = serverhome
    cmd = ["java", "-Djava.io.tmpdir=#{javatmp}", "-jar", Hudson::WAR]
    cmd << "--daemon" if options[:daemon]
    cmd << "--logfile=#{File.expand_path(options[:logfile])}" if options[:logfile]
    cmd << "--httpPort=#{options[:port]}"
    cmd << "--controlPort=#{options[:control]}"
    #puts cmd.join(" ")
    exec(*cmd)
    
  when :create
    opts = OptionParser.new do |opts|
      opts.banner = "Usage: hudson create [project_path] [options]"
      opts.on("-n", "--name [dir_name]", "name of hudson job") { |name| options[:name] = name }
      common_hudson_options(opts, options)
    end
    
    opts.parse!(args)
    project_path = args.shift || "."
    FileUtils.chdir(project_path) do
      unless scm = Hudson::ProjectScm.discover
        error "Cannot determine project SCM. Currently supported: #{Hudson::ProjectScm.supported}"
      end
      job_config = Hudson::JobConfigBuilder.new(:rubygem) do |c|
        c.scm = scm.url
      end
      name = options[:name] || File.basename(FileUtils.pwd)
      Hudson::Api.setup_base_url(options[:host], options[:port])
      if Hudson::Api.create_job(name, job_config)
        build_url = "http://#{options[:host]}:#{options[:port]}/job/#{name.gsub(/\s/,'%20')}/build"
        puts "Added project '#{name}' to Hudson."
        puts "Trigger builds via: #{build_url}"
      else
        error "Failed to create project '#{name}'"
      end
    end
  when :list
    opts = OptionParser.new do |opts|
      opts.banner = "Usage: hudson list [project_path] [options]"
      common_hudson_options(opts, options)
    end
    
    opts.parse!(args)
    project_path = args.shift || "."
    FileUtils.chdir(project_path) do
      Hudson::Api.setup_base_url(options[:host], options[:port])
      if summary = Hudson::Api.summary
        if summary["jobs"]
          summary["jobs"].each do |job|
            color = job['color']
            color = 'green' if color == 'blue'
            color = 'reset' unless Term::ANSIColor.respond_to?(color.to_sym)
            name, url, color = job['name'], job['url'], c.send(color)
            print color, name, c.reset, " - ", url, "\n"
          end
        else
          display "No jobs found on #{options[:host]}:#{options[:port]}"
        end
      else
        error "Failed connection to #{options[:host]}:#{options[:port]}"
      end
    end
  else
    opts.parse!([command, *args])
    error "Unknown command '#{command}'"
  end
else
  help(opts)
end

